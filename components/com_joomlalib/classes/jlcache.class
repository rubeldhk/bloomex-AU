<?php
/**
 * Caching class for data, functions and objects
 * 
 * With the addition that it's stored on application layer and not in general cache directory
 * So it isn't affect by random cache cleaning that seem to happen in joomla and with the ability to set 
 * A timeout per group.
 * 
 * based on Cache_Lite by Fabien MARTY
 *
 * @package JL
 */
defined('_JOOMLALIB') or die( 'Direct Access to this location is not allowed.' );
/** @ignore */
require_once(JLCoreApi::getBasePath().'/includes/Cache/Lite.php');
JLCoreApi::import('JLApp');
/**
 * JlCache
 *
 * @package JL
 * @subpackage JLCache
 */
class JLCache extends Cache_Lite {
	/**
	 * application id
	 * @var integer
	 */
	var $_appId;
	/**
	 * Array holding group timeout settings
	 * @var array
	 */
	var $groups;
	/**
	 * default timeout in seconds
	 * @var integer
	 */
	var $_defaultTimeout;
	
	/**
	 * error string
	 * @var string
	 */
	var $errorStr;
	
	/**
	 * Construct
	 *
	 * @param string application handle
	 * @param integer default cache time in seconds
	 * @param array options see cache_lite, these can't be used: fileNameProtection, lifetime, cacheDir
	 * @return JLCache
	 */
	function JLCache($appHandle, $defaultLifetime, $options=array(null)){
		$this->errorStr = '';
		
		$this->_appId = JLApp::getId($appHandle);
		
		/* adjust the settings to work with JLCache, no more user input below this */
		$options['fileNameProtection'] = true;
		$options['lifeTime'] = $defaultLifetime;
		$this->_defaultTimeout = $defaultLifetime;
		
		/* set the storage directory */
		$cacheDir = dirname(dirname(__FILE__)).'/cache/'.$this->_appId.'/';
		if(!@is_dir($cacheDir)) {
			$st = @mkdir($cacheDir, 0777);
			if($st === false) {
				$this->errorStr = sprintf("Unable to create cache folder '%s'", $cacheDir);
			}
			clearstatcache();
		}
		
		if(!is_writable($cacheDir)) {
			$this->errorStr = sprintf("Cache directory '%s' was not writeable after creation.", $cacheDir);
		}
		
		$options['cacheDir'] = $cacheDir;
		 
		$this->Cache_Lite($options);
	}
	
	/**
	 * Get cache data
	 *
	 * @param string $id
	 * @param string $group
	 * @return mixed data on succes, boolean false on failure
	 */
	function getCache($id, $group = 'default'){
		/* set group timeout */
		$this->setLifeTime($this->getGroupTime($group));
		return $this->get($id, $group);
	}
	
	/**
	 * Saves Cache data
	 *
	 * @param string $data
	 * @param string $id
	 * @param string $group
	 * @return boolean
	 */
	function saveCache($data, $id, $group = 'default'){
		return $this->save($data, $id, $group);
	}
	
	/**
	 * Adds a group with timeout settings to object
	 *
	 * @param string, groupname
	 * @param integer, seconds before timing out, default to "default" group if left empty
	 */
	function addGroup($group , $timeout = null){
		if(empty($timeout)){
			$timeout = $this->_defaultTimeout;
		}
		$this->groups[$group] = (int) $timeout;
	}
	
	/**
	 * Get's time out setting for a group
	 *
	 * @param string, groupname
	 * @return integer
	 */
	function getGroupTime($group){
		if(!isset($this->groups[$group])){
			return $this->_defaultTimeout;
		}
		return $this->groups[$group];
	}
}

/**
 * Cache object to cache objects
 * 
 * @package JL
 * @subpackage JLCache
 */
class JLCacheObject extends JLCache {
	
	function JLCacheObject($appHandle, $defaultLifetime, $options=array(null)) {
		$this->JLCache($appHandle, $defaultLifetime, $options);
	}
	
	/**
	 * Save object into cache 
	 *
	 * @param string $id
	 * @param object object to be stored
	 * @param array array containing full server paths to files needed by object
	 * @param string groupname
	 * @return boolean
	 */
	function saveCache($id, $object, $files = array(null), $group='default'){
		$object = serialize($object);
		$data = array($files, $object);
		if(!$this->_automaticSerialization){
			$data = serialize($data);
		}
		return $this->save($data, $id, $group);
	}
	
	/**
	 * Get a cache object
	 *
	 * @param string $id
	 * @param string $group
	 * @return object
	 */
	function getCache($id, $group = 'default'){
		/* set group timeout */
		$this->setLifeTime($this->getGroupTime($group));
		
		$data = $this->get($id, $group);
		if (!$data) {
			return false;
		}
		
		if(!$this->_automaticSerialization){
			$data = unserialize($data);
		}
		
		list($files, $object) = $data; 
		foreach($files as $location){
			require_once($location);
		}
		
		return unserialize($object);
	}
}

/**
 * Caching object for functions
 *
 * @package JL
 * @subpackage JLCache
 */
class JLCacheFunction extends JLCache {
	
	function JLCacheFunction($appHandle, $defaultLifetime, $options=array(null)) {
		$this->JLCache($appHandle, $defaultLifetime, $options);
	}
	
	/**
	* Calls a cacheable function or method (or not if there is already a cache for it)
	*
	* Arguments of this method are read with func_get_args. So it doesn't appear
	* in the function definition. Synopsis :
	* call('group', 'functionName', $arg1, $arg2, ...)
	* (arg1, arg2... are arguments of 'functionName')
	*
	* @return mixed result of the function/method
	* @access public
	*/
	function call() {
		$arguments = func_get_args();
		$group = array_shift($arguments);
		$id = serialize($arguments);
		
		if (!$this->_fileNameProtection) {
			$id = md5($id);
			// if fileNameProtection is set to false, then the id has to be hashed
			// because it's a very bad file name in most cases
		}
		$data = $this->getCache($id, $group);
		if ($data !== false) {
			$array = unserialize($data);
			$output = $array['output'];
			$result = $array['result'];
		} else {
			ob_start();
			ob_implicit_flush(false);
			$target = array_shift($arguments);
			if (strstr($target, '::')) { // classname::staticMethod
				list($class, $method) = explode('::', $target);
				$result = call_user_func_array(array($class, $method), $arguments);
			} else if (strstr($target, '->')) { // object->method
				// use a stupid name ($objet_123456789 because) of problems when the object
				// name is the same as this var name
				list($object_123456789, $method) = explode('->', $target);
				global $$object_123456789;
				$result = call_user_func_array(array($$object_123456789, $method), $arguments);
			} else { // function
				$result = call_user_func_array($target, $arguments);
			}
			$output = ob_get_contents();
			ob_end_clean();
			$array['output'] = $output;
			$array['result'] = $result;
			$this->saveCache(serialize($array), $id, $group);
		}
		echo($output);
		return $result;
	}
}
?>